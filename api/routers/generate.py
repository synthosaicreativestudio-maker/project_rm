from fastapi import APIRouter, HTTPException, BackgroundTasks
from api.models import GenerateImageRequest, GenerateVideoRequest, GenerateRequest, StatusResponse
from services.gemini import gemini_service
from services.veo import veo_service
from config.settings import settings
from aiogram import Bot
from aiogram.types import BufferedInputFile
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

# Initialize Bot for sending notifications
# Note: In a production environment with high load, you might want to use a shared connection or a different architecture.
bot = Bot(token=settings.BOT_TOKEN)

async def process_generation_task(user_id: int, action_type: str, prompt: str, params: dict):
    """
    Background task to handle heavy generation and notify user via Telegram.
    """
    try:
        logger.info(f"Starting background generation for user {user_id}: {action_type}")
        
        if action_type == 'image':
            model_id = "gemini-3-pro-image-preview"
            await bot.send_message(chat_id=user_id, text=f"üé® {model_id} —Ä–∏—Å—É–µ—Ç...")
            
            aspect_ratio = params.get('aspectRatio', '1:1')
            image_bytes = await gemini_service.generate_image(prompt, aspect_ratio=aspect_ratio)
            
            if image_bytes:
                photo_file = BufferedInputFile(image_bytes, filename="generated_image.png")
                await bot.send_photo(chat_id=user_id, photo=photo_file, caption=f"‚ú® Generated by {model_id}\nPrompt: {prompt}")
            else:
                await bot.send_message(chat_id=user_id, text="‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")

        elif action_type == 'video':
            model_id = "veo-3.1-fast-generate-001"
            await bot.send_message(chat_id=user_id, text=f"üé• {model_id} –Ω–∞—á–∞–ª–∞ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥...")
            
            video_uri = await veo_service.generate_video(prompt)
            
            if video_uri:
                 await bot.send_message(chat_id=user_id, text=f"üé¨ –ì–æ—Ç–æ–≤–æ! –†–µ–∑—É–ª—å—Ç–∞—Ç: {video_uri}")
            else:
                 await bot.send_message(chat_id=user_id, text="‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ (–≤–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–µ–≤—ã—à–µ–Ω–∞ –∫–≤–æ—Ç–∞).")

    except Exception as e:
        logger.error(f"Error in process_generation_task: {e}")
        try:
            await bot.send_message(chat_id=user_id, text=f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {str(e)}")
        except Exception as send_err:
             logger.error(f"Failed to send error message to user: {send_err}")
    finally:
        # We don't close the bot session here because we reuse it? 
        # Actually aiogram Bot session is connection pooled. 
        # But if we create a new instance globally, we should manage its lifecycle.
        # For simple use case, letting it manage itself is okay, but explicit close on app shutdown is better.
        pass

@router.post("/image/", response_model=StatusResponse)
async def generate_image(request: GenerateImageRequest):
    # Mock generation endpoint from original code
    logger.info(f"IMAGE GEN REQUEST: {request}")
    return StatusResponse(status='success', message=f'Image generation started for: {request.prompt}')

@router.post("/video/", response_model=StatusResponse)
async def generate_video(request: GenerateVideoRequest):
    # This was originally blocking or half-blocking.
    # We will try to generate immediately or delegates.
    # Replicating original logic: await generation and return URI if successful.
    
    try:
        video_uri = await veo_service.generate_video(request.prompt)
        if video_uri:
             return StatusResponse(status='success', video_uri=video_uri)
        else:
             raise HTTPException(status_code=500, detail="Generation failed or quota exceeded")
    except Exception as e:
        logger.error(f"Error in generate_video: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/", response_model=StatusResponse)
async def generate(request: GenerateRequest, background_tasks: BackgroundTasks):
    """
    Main entry point for WebApp generation.
    Starts a background task and notifies user via Telegram Bot.
    """
    if not request.user_id:
         raise HTTPException(status_code=400, detail="user_id is required")

    # Notify user immediately
    try:
        await bot.send_message(chat_id=request.user_id, text=f"‚úÖ –ó–∞–¥–∞—á–∞ –ø–æ–ª—É—á–µ–Ω–∞: {request.type.upper()}\n–ü—Ä–æ–º—Ç: {request.prompt[:50]}...")
    except Exception as e:
         logger.error(f"Failed to send initial confirmation: {e}")
         # Continue anyway to process task? Or fail? 
         # Likely fail if bot can't reach user.
         pass

    # Add background task
    background_tasks.add_task(
        process_generation_task, 
        request.user_id, 
        request.type, 
        request.prompt, 
        request.params
    )
    
    return StatusResponse(status='success', message='Task started')
